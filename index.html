<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Aurelia Presentation</title>

		<meta name="description" content="Aurelia is a JavaScript client framework for mobile, desktop and web leveraging simple conventions and empowering creativity">
		<meta name="author" content="Daniela Baron">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Custom styles -->
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-transition="convex">
					<a href="#" class="navigate-down">
						<img width="573" height="170" data-src="images/aurelia-logo.png" alt="Aurelia Logo"
							style="border: none; background: none; box-shadow: none;">
					</a>
					<h3>A JavaScript Client Framework</h3>
					<p>
						<small>Presented by:
						<ul>
							<li><a href="https://github.com/mlaccetti">Michael Laccetti</a></li>
							<li><a href="https://github.com/Ghnuberath">Sean McIntyre</a></li>
							<li><a href="https://github.com/plaliberte">Phil Laliberte</a></li>
							<li><a href="https://github.com/danielabar">Daniela Baron</a></li>
							<li><a href="https://github.com/zeroviscosity">Kent English</a></li>
						</ul>
						</small>
					</p>
				</section>

				<!-- BEGIN Sean: ES2015 Overview -->
				<section>
					<section>
						<h2>ES6/ES7 (ES2015/2016) Overview</h2>
						<p>
							JavaScript that doesn't suck :)
						</p>
					</section>
					<section>
						<h2><code>var</code> is dead.<br/>Long live <code>let</code> &amp; <code>const</code></h2>
					</section>
					<section>
						<h3>Constants!</h3>
						<pre class="presentation-code"><code class="hljs" data-trim>
var pi = 3.141592653;
// is now
const pi = 3.141592653;
						</code></pre>
					</section>
					<section>
						<h3>Block scoping!</h3>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// this works. stop the insanity.
for (var i=0; i<10; i++) {
	console.log(i);
}
console.log(i);
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// this does not work :)
for (let i=0; i<10; i++) {
	console.log(i);
}
console.log(i);
					</code></pre>
					</section>
					<section>
						<h2>Arrow Notation</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
[1,2,3].map(a => a+1);
					  </code></pre>
						<div class="fragment">
							<h3>Lexical <code>this</code></h3>
							<pre class="presentation-code fragment"><code class="hljs" data-trim>
function() {
	var self = this;
	self.name = 'Sean';
	setInterval(function() {
		console.log(self.name); // ugly :(
	});
}
						  </code></pre>
							<pre class="presentation-code fragment"><code class="hljs" data-trim>
function() {
	this.name = 'Sean';
	setInterval(() => {
		console.log(this.name); // => shares the same this
		                        // with the surrounding code!
	});
}
						  </code></pre>
						</div>
					</section>
					<section>
						<h2>Classes<br/><small class="fragment">(finally)</small></h2>
					</section>
					<section>
						<pre class="presentation-code"><code class="hljs" data-trim>
class Person {
	constructor(firstName, lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	getFullName() {
		return this.firstName + ' ' + this.lastName;
	}
}
						</code></pre>
					</section>
					<section>
						<pre class="presentation-code"><code class="hljs" data-trim>
class Developer extends Person {
	// static method called with Developer.curse();
	static curse() { return 'thou shalt forever be off by one...'; }

	constructor(firstName, lastName, isRemote) {
		super(firstName, lastName);
		this._isRemote = isRemote;
	}

	// getter, used via developerInstance.isRemote
	get isRemote() { return this._isRemote; }
	// setter, used via developerInstance.isRemote = false
	set isRemote(newIsRemote) {
		throw new Error('Cannot re-assign isRemote!');
	}
}
						</code></pre>
					</section>
					<section>
						<h2>Decorators</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
@isTestable(true)
class Person {
	constructor(firstName, lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	@readonly
	getFullName() {
		return this.firstName + ' ' + this.lastName;
	}
}
						</code></pre>
						<div class="fragment">
							<p>
								Decorators are annotations which allow you to define cross-cutting modifications to classes and methods.
							</p>
							<p>
								Decorators are executed at runtime.
							</p>
						</div>
					</section>
					<section>
						<p>
							Built-in classes like <code>Array</code>, <code>Date</code> and DOM <code>Element</code>s can be subclassed!
						</p>
					</section>
					<section>
						<h2>Modules</h2>
						<p class="fragment">
							Making module syntax a native part of the language!
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// app.js
import * as math from "lib/math";
alert("2π = " + math.sum(math.pi, math.pi));
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// otherApp.js
import {sum, pi} from "lib/math";
alert("2π = " + sum(pi, pi));
						</code></pre>
					</section>
					<section>
						<h2>Template strings</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
/* before, in Person, we had this: */
getFullName() {
	return this.firstName + ' ' + this.lastName;
}
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
/* now we can do this!*/
getFullName() {
	return `${this.firstName} ${this.lastName}`;
}
						</code></pre>
					</section>
					<section>
						<h2>for...of (Iterators)</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
let a = ['a','b','c'];
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
for (let i in a) {
  console.log(i);
}
// prints 0 1 2 (which is pretty useless)
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
for (let i of a) {
	console.log(prop);
}
// prints a b c :)
						</code></pre>
						<p class="fragment">
							You can use the Iterator protocol in your own functions and classes to make anything iterable via <code>for...of</code>
						</p>
					</section>
					<section>
						<h2>Default, Rest and Spread</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}
f(3) == 15
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, ...y) {
  // y is an Array
  return x * y.length;
}
f(3, "hello", true) == 6
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) == 6
						</code></pre>
					</section>
					<section>
						<h2>Destructuring</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
let a, b, rest;

[a, b] = [1, 2]
{a, b} = {a:1, b:2}
// a === 1, b === 2

[a, b, ...rest] = [1, 2, 3, 4, 5]
// a === 1, b === 2, rest === [3,4,5]
						</code></pre>
					</section>
					<section>
						<h2>Destructuring<br/> <small>(multiple return values)</small></h2>
						<pre class="presentation-code"><code class="hljs" data-trim>
function f() {
	return [1,2];
}
[a, b] = f();
						</code></pre>
					</section>
					<section>
						<h2><code>Set</code>s and <code>Map</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const s = new Set();
s.add("hello").add("goodbye").add("hello");
s.size === 2;
s.has("hello") === true;
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const m = new Map();
m.set("hello", 42);
m.set("goodbye", 34);
m.get("goodbye") == 34;
						</code></pre>
					</section>
					<section>
						<h2><code>WeakMap</code>s and <code>WeakSet</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const obj = {
	// ...
}
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const wm = new WeakMap();
wm.set(obj, 42); // store some metadata about obj.
						</code></pre>
						<ul>
							<li class="fragment">Keys in a <code>WeakMap</code> must be objects</li>
							<li class="fragment"><code>WeakMap</code>s do not hold a strong reference to their keys.</li>
							<li class="fragment">Great way to store additional metadata on an object without polluting it.</li>
							<li class="fragment">WeakSets are similar</li>
						</ul>
					</section>
					<section>
						<h2>Native <code>Promise</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const p = new Promise((resolve, reject) => {
	setTimeout(() => {
		Math.random() < 0.5 ? resolve() : reject();
	}, 500);
});

p.then(() => {
	console.log('Resolved!');
})
.catch(() => {
	console.log('Rejected!');
});
						</code></pre>
					</section>
					<section>
						<h2>Generators</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function *getTime() {
	while(true) {
		yield Date.now();
	}
}
const timer = getTime();
console.log(timer.next()); // { value: 1454906307698, done: false }
console.log(timer.next()); // { value: 1454906307710, done: false }
console.log(timer.next()); // { value: 1454906307711, done: false }
						</code></pre>
						<p class="fragment">You can also use the <code>for...of</code> loop with Generators :)</p>
					</section>
					<section>
						<h2>Generators<br/><small>two-way communication</small></h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const summer = (function *sum() {
	let sum = 0;
	while(true) {
		sum += yield sum;
	}
})();
summer.next(); // start summer by making it yield once
// now we can pump values into it, and receive the current sum
console.log(summer.next(1)); // { value: 1, done: false }
console.log(summer.next(2)); // { value: 3, done: false }
console.log(summer.next(3)); // { value: 6, done: false }
						</code></pre>
						<p class="fragment"><small>Calling <code>next()</code> on a generator makes it pause execution. When the generator is restarted by another call to <code>next()</code>, the argument passed to <code>next()</code> replaces the yield expression.</small></p>
					</section>
					<section>
						<h2>Now for the crazy part...</h2>
					</section>
					<section>
						<h2>Generators</br><small>as a way to avoid callbacks</small></h2>
						<div class="fragment">
							<p>
								 Let's say we have some asynchronous function<br/> returning a Promise:
							</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
function longRunning(done) {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve(Math.random());
		}, 500);
	});
}
							</code></pre>
						</div>
					</section>
					<section>
						<p>Normally, we'd use it like this:</p>
						<pre class="presentation-code"><code class="hljs" data-trim>
longRunning.then((result) => {
	console.log(result);
})
						</code></pre>
					</section>
					<section>
						<div>
							<p>But now we can do something like this...</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning();
	console.log(s);
}();
							</code></pre>
						</div>
						<div class="fragment">
							<p>With the assistance of this horrifying statement:</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
script.next().value.then((r) => {
	script.next(r);
});
							</code></pre>
						</div>
					</section>
					<section>
						<p>
							Treating async code like it's synchronous is awesome!
						</p>
						<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning(); // so cool!
	console.log(s);
}();
						</code></pre>
						<p class="fragment">
							So how do we avoid the horror?
						</p>
					</section>
					<section>
						<h2>ES2016 <code>async...await</code></h2>
						<div class="fragment">
							<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning();
	console.log(s);
}();
script.next().value.then((r) => {
	script.next(r);
});
							</code></pre>
						</div>
						<p class="fragment">
							becomes...
						</p>
						<div class="fragment">
							<pre class="presentation-code"><code class="hljs" data-trim>
(async function script() {
	let s = await longRunning(); // even cooler!
	console.log(s);
})();
// no ugliness!
							</code></pre>
						</div>
					</section>
					<section>
						<p>
							Or, more realistically...
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
(async function script() {
	try {
		let s = await longRunning(); // sequential async
		let t = await anotherLongRunning();
		console.log(s + t);
	} catch (err) {
		console.error(err);
	}
})();
						</code></pre>
						<p class="fragment">
							Notice that good old-fashioned <code>try-catch</code> blocks work again!
						</p>
					</section>
					<section>
						<p>
							Or, for parallel async
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
(async function script() {
	try {
		let [s,t] = await Promise.all(
			longRunning(),
			anotherLongRunning()
		);
		console.log(s + t);
	} catch (err) {
		console.error(err);
	}
})();
						</code></pre>
					</section>
					<section>
						<p>Almost all of this is available in Node.js natively, right now!</p>
						<p class="fragment">
							If you're not using it...start. My eyes will thank you.
						</p>
						<div class="fragment">
							<p>
								If you want to use this in the browser, you'll need to use a <strong>transpiler</strong> until the ES2015 and ES2016 specifications are implemented natively. Popular transpilers include:
							</p>
							<ul>
								<li><a href="http://babeljs.io/">Babel</a></li>
								<li><a href="https://github.com/google/traceur-compiler">Traceur</a></li>
							</ul>
						</div>
					</section>
					<section>
						<h2>ES2015/ES2016<br/><small>Further reading</small></h2>
						<p>
							For more information, the <a href="http://babeljs.io/docs/learn-es2015/">Babel docs</a> are a good reference
						</p>
						<p>
							As is the Mozilla Developer Network <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">JavaScript reference</a>
						</p>
						<div class="fragment">
							Stuff I didn't cover:
							<ul>
								<li>Symbols (new basic type, allowing private class members)</li>
								<li>Proxies</li>
								<li>New Math, Number, String and Object APIs</li>
								<li>Binary and Octal literals</li>
								<li>Reflection API</li>
								<li>Tail recursion</li>
							</ul>
						</div>
					</section>
				</section>
				<!-- END Sean: ES6 Overview -->

				<!-- BEGIN Phil: Aurelia Overview -->
				<section>
					<section>
						<h2>What is it?</h2>
						<h2>Why should you care?</h2>
					</section>

					<section>
						<h2>Modern</h2>
						<p>
							<ul>
								<li class="fragment">
									<div>Modern javascript</div>
									<small>Write in ES6, ES7, Typescript... or ES5</small>
								</li>
								<li class="fragment">
									<div>Modern DOM</div>
									<small>Automatically polyfills older browser support</small>
								</li>
								<li class="fragment">
									<div>Modern Tooling</div>
									<small><em class="fragment">*</em>JSPM, Gulp, Karma, Protractor</small>
								</li>
							</ul>
						</p>
						<p class="fragment"><em>* Presenter does not officially endorse JSPM</em></p>
					</section>

					<section>
						<h2>Components!</h2>
						<p>
							<ul>
								<li>HTMLTemplateElement and ShadowDOM</li>
								<li>Aurelia Component Lifecycle</li>
								<li>Modularity</li>
							</ul>
						</p>

						<img width="80%" height="auto" class="fragment" data-src="images/happiness.gif" alt="Aurelia Logo"
							style="border: none; background: none; box-shadow: none;">
					</section>

					<section data-state="compete">
						<p class="david">
							<img src="images/durandal-logo.png" alt="Durandal logo"> <img src="images/aurelia-logo.png" alt="Aurelia logo">	
						</p>
						<h2 class="fragment">How can it compete?</h2>
						<div class="goliath fragment">
							<img src="images/facebook-logo.png" alt="Facebook logo"> <img src="images/react-logo.svg" alt="React logo">	
						</div>
						<div class="goliath fragment">
							<img src="images/google-logo.png" alt="Google logo"> <img src="images/angular-logo-light.png" alt="angular logo">	
						</div>
					</section>
				</section>
				<!-- END Phil: Aurelia Overview -->

				<!-- BEGIN Daniela: Aurelia vs Angular -->
				<section>
					<section data-transition="fade" data-state="subsection-start" data-background="images/kids-boxing.png" data-background-size="80%">
						<h2>Aurelia vs Angular 1.x</h2>
					</section>

					<section>
						<h2>Similarities</h2>
						<ul>
							<li class="fragment">Make SPA development easier</li>
							<li class="fragment">Routing and deep linking</li>
							<li class="fragment">Data binding</li>
							<li class="fragment">HTML customization</li>
						</ul>
					</section>

					<section>
						<h2>&ldquo;Angular Script&rdquo;</h2>
							<p>
								<span class="fragment block">angular.module</span>
								<span class="fragment block">...controller</span>
							</p>
							<p>
								<span class="fragment block">...factory</span>
								<span class="fragment block">...service</span>
							</p>
							<p>
								<span class="fragment block">...provider</span>
								<span class="fragment block">...filter</span>
							</p>
					</section>

					<section data-state="just-es">
						<h2>Aurelia: Just classes</h2>
						<table>
							<tr class="fragment">
								<td>View Model<br>(Controller)</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
export class Users {
	constructor() { ... }
	activate() { ... }
}
									</code></pre>
								</td>
								<td>Service<br>(Factory)</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
export class MyService {
	constructor() { ... }
	doSomething() { ... }
}
									</code></pre>
								</td>
							</tr>
							<tr class="fragment">
								<td>Value Converter<br>(Filter)</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
export class MyValueConverter {
	constructor() { ... }
	toView(value) { ... }
}
									</code></pre>
								</td>
								<td colspan="2" class="message-emphasis">No framework specific code required!</td>
							</tr>
						</table>
					</section>

					<section>
						<h2>&ldquo;Angular Script&rdquo; vs ES 2015</h2>
						<pre class="fragment presentation-code hack-col-left"><code class="hljs" data-trim>
angular.module('myApp', [ 'ngRoute' ])
	.config(function ($routeProvider) {
    $routeProvider
      .when('/users', {
				templateUrl: 'views/users.html',
        controller: 'UsersController',
        controllerAs: 'usersController',
        resolve: {
          users: function(UserService) {
            return UserService.getAll();
          }
        }
			})
			.otherwise({ redirectTo: '/' });
  });
&nbsp;
						</code></pre>
						<pre class="fragment presentation-code hack-col-right"><code class="hljs" data-trim>
export class App {

  configureRouter(config, router) {
    config.map([
      { route: ['', 'users'], moduleId: 'users' }
    ]);

    this.router = router;
  }

}
							</code></pre>
					</section>

					<section data-state="dependency-injection">
						<h2>Dependency Injection: Angular</h2>
						<pre class="fragment presentation-code"><code class="hljs" data-trim>
angular.module('myApp').controller('UserController',
['users', 'UserService', '$rootScope', 'toastr', '$state',
function (users, UserService, $rootScope, toastr, $state) {
		// ...
}]);
						</code></pre>
						<p class="fragment">Where did the dependencies come from??</p>
						<table>
							<tr class="fragment">
								<td><code>users</code></td>
								<td>Router resolve (data!)</td>
							</tr>
							<tr class="fragment">
								<td><code>UserService</code></td>
								<td>Application factory</td>
							</tr>
							<tr class="fragment">
								<td><code>$rootScope</code></td>
								<td>Angular core</td>
							</tr>
							<tr class="fragment">
								<td><code>toastr</code></td>
								<td>Notification library</td>
							</tr>
							<tr class="fragment">
								<td><code>$state</code></td>
								<td>UI Router (not Angular)</td>
							</tr>
						</table>
						<img class="fragment" src="images/magic.jpg" alt="magic" width="720" height="540">
					</section>

					<section data-state="di-aurelia">
						<h2>Dependency Injection: Aurelia</h2>
						<!-- First code snippet -->
						<div class="fragment">
						<pre class="hack-col-left presentation-code "><code class="hljs" data-trim>
import {inject} from 'aurelia-framework';
import {UserService} from 'users/user-service';
import {EventAggregator} from
	'aurelia-event-aggregator';
import * as toastr from 'toastr';
						</code></pre>
						<div class=" hack-col-right">
							<p>Injection service and dependencies imported.</p>
						</div>
						</div>
						<!-- Second code snippet -->
						<div class="fragment">
						<pre class="hack-col-left presentation-code "><code class="hljs" data-trim>
import {inject} from 'aurelia-framework';
import {UserService} from 'users/user-service';
import {EventAggregator} from
	'aurelia-event-aggregator';
import * as toastr from 'toastr';

@inject(UserService, EventAggregator, toastr)
export class Users {

}
						</code></pre>
						<div class="hack-col-right">
							<p>Injection service and dependencies imported.</p>
							<p>Injection via decorator.</p>
						</div>
						</div>
						<!-- Third code snippet -->
						<div class="fragment">
						<pre class="hack-col-left presentation-code "><code class="hljs" data-trim>
import {inject} from 'aurelia-framework';
import {UserService} from 'users/user-service';
import {EventAggregator} from
	'aurelia-event-aggregator';
import * as toastr from 'toastr';

@inject(UserService, EventAggregator, toastr)
export class Users {

	constructor(userService, eventAggregator, toastr) {
		this.userService = userService;
		this.eventAggregator = eventAggregator;
		this.toastr = toastr;
	}
}
						</code></pre>
						<div class="hack-col-right">
							<p>Injection service and dependencies imported.</p>
							<p>Injection via decorator.</p>
							<p>Deps injected as constructor args.</p>
						</div>
						</div>
						<!-- Fourth code snippet -->
						<pre class="hack-col-left presentation-code fragment"><code class="hljs" data-trim>
import {inject} from 'aurelia-framework';
import {UserService} from 'users/user-service';
import {EventAggregator} from
	'aurelia-event-aggregator';
import * as toastr from 'toastr';

@inject(UserService, EventAggregator, toastr)
export class Users {

	constructor(userService, eventAggregator, toastr) {
		this.userService = userService;
		this.eventAggregator = eventAggregator;
		this.toastr = toastr;
	}

	activate(params) {
		return this.userService.getAll()
			.then( users => this.users = users );
	}
}
						</code></pre>
						<div class="fragment hack-col-right">
							<p>Injection service and dependencies imported.</p>
							<p>Injection via decorator.</p>
							<p>Deps injected as constructor args.</p>
							<p>
								Lifecycle activate method invoked with view state.
								<a href="https://github.com/aurelia/documentation/blob/master/English/docs.md#the-screen-activation-lifecycle">Screen Activation Lifecycle</a>
							</p>
						</div>
					</section>

					<section data-state="angular-compare-db">
						<h2>Data Binding</h2>
						<table>
							<col width="50%">
  						<col width="50%">
							<tr>
								<th><img src="images/aurelia-logo.png" alt="Aurelia logo"></th>
								<th><img src="images/angular-logo-light.png" alt="Angular logo"></th>
							</tr>
							<tr class="fragment">
								<td>Append <code>.bind</code> to any html or custom attribute.</td>
								<td>Uses Angular-specific custom attributes.</td>
							</tr>
							<tr class="fragment">
								<td>Defaults to two-way for input, one-way for everything else.</td>
								<td>Two-way all the time, except for custom directives.</td>
							</tr>
							<tr class="fragment">
								<td>Want more control? <code>.one-way</code>, <code>.two-way</code>, <code>.one-time</code>.</td>
								<td>Each binding adds a watcher on the <code>$scope</code> model.</td>
							</tr>
							<tr class="fragment">
								<td><a href="https://github.com/aurelia/documentation/blob/master/English/docs.md#adaptive-binding">Adaptive Binding</a> picks optimal observation strategy &amp; minimizes dirty checking.</td>
								<td>Built in directives trigger digest cycle on scope model changes (dirty checking).</td>
							</tr>
						</table>
					</section>

					<section data-state="angular-compare-db-code">
						<h2>Data Binding Examples</h2>
						<table>
							<tr>
								<th><img src="images/aurelia-logo.png" alt="Aurelia logo"></th>
								<th><img src="images/angular-logo-light.png" alt="Angular logo"></th>
							</tr>
							<!-- Example 1: Input binding -->
							<tr class="fragment">
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<input type="text" value.bind="user.name">
									</code></pre>
								</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<input type="text" ng-model="user.name">
									</code></pre>
								</td>
							</tr>
							<!-- Example 2: Class binding -->
							<tr class="fragment">
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<div class.bind="row.isActive ? 'active' : ''">
	some content
</div>
									</code></pre>
								</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<div ng-class="row.isActive ? 'active' : ''">
	some content
</div>
									</code></pre>
								</td>
							</tr>
							<!-- Example 3: Binding to custom attribute 'show' -->
							<tr class="fragment">
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<div show.bind="hasError" class="error">
	${err.message}
</div>
									</code></pre>
								</td>
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<div ng-show="hasError" class="error">
	{{ err.message }}
</div>
									</code></pre>
								</td>
							</tr>
							<!-- Example 4: Explicit two-way binding for custom element -->
							<tr class="fragment">
								<td>
									<pre class="presentation-code"><code class="hljs" data-trim>
<my-datepicker data.two-way="user.dob">
</my-datepicker>
									</code></pre>
								</td>
								<td>
								<pre class="presentation-code"><code class="hljs" data-trim>
<my-datepicker data="user.dob">
</my-datepicker>
								</code></pre>
								</td>
							</tr>
						</table>
					</section>

					<section data-state="dom-manipulation">
						<h3>HMTL Customization</h3>
							<table class="fragment">
								<tr>
									<th align="center"><img src="images/aurelia-logo.png" alt="Aurelia logo"></th>
									<th align="center"><img src="images/angular-logo-light.png" alt="Angular logo"></th>
								</tr>
								<tr>
									<td>
										<pre class="presentation-code"><code class="hljs" data-trim>
<require from="../components/mydatepicker">
</require>
&nbsp;
<my-datepicker data.two-way="user.dob">
</my-datepicker>
									</code></pre>
								</td>
									<td>
										<pre class="presentation-code"><code class="hljs" data-trim>
<my-datepicker
data="user.dob">
</my-datepicker>
									</code></pre>
								</td>
						</tr>
							</table>
						<p class="fragment">Usage looks similar, devil is in the implementation details...</p>
					</section>

					<section data-state="ang-dir">
						<h2>Angular Directive</h2>
						<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
angular.module('myApp').directive('myDatepicker',
	function () {
    return {
      templateUrl: 'views/mydatepicker.html',
			restrict: 'E',
			scope: { data: '=' },

			controller: function($scope, $element) {
				// Directive-specific logic
			},

      link: function postLink(scope, element) {
        // DOM manipulation here
      }
    };
  });
						</code></pre>
						<div class="hack-col-right">
							<p class="fragment">Configure template.</p>
							<p class="fragment"><code>restrict</code>&nbsp;&nbsp;specifies 'E' or 'A' for element or attribute.</p>
							<p class="fragment">Isolate scope, o.w. can access parent!</p>
							<p class="fragment">'=' indicates two-way data binding, '@' for one way, '&' for binding functions.</p>
							<p class="fragment">Controller function runs first, then Link function.</p>
						</div>
					</section>

					<section data-state="ang-dir">
						<h2>Directive: Datepicker</h2>
						<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
link: function(scope, element) {
	// Initialize datepicker
	element.find('.date').datepicker();

	// Try to update data binding?
	element.find('.date').datepicker().on('changeDate',
		function(e) {
			scope.data = e.date;
		}
	);
}
						</code></pre>
						<div class="hack-col-right">
							<p class="fragment">Element will not update because event happened outside of <span class="emphasis">Angular&rsquo;s context</span>.</p>
						</div>
						<pre class="fragment presentation-code hack-col-left"><code class="hljs" data-trim>
link: function(scope, element) {
	// Initialize datepicker
	element.datepicker();

	// Update data binding
	element.datepicker().on('changeDate',
		function(e) {
			scope.$apply(function () {
				scope.data = e.date;
			});
	});
}
						</code></pre>
						<div class="hack-col-right" style="top: 180%;">
							<p class="fragment">Run update inside <code>scope.$apply</code> to trigger a digest cycle.</p>
						</div>
					</section>

					<section data-state="ang-dir">
						<h2>Directive: Watch</h2>
						<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
link: function(scope, element) {
	// ...
	
	scope.$watch('data',
		function(newVal) {
    	element.datepicker('setDate', newVal);
  	});

}
						</code></pre>
						<div class="hack-col-right">
							<p>To have datepicker respond to model changes, must add <code>scope.$watch</code> to add to list of watchers evaluated in digest cycle.</p>
						</div>
					</section>

				<section data-state="ang-dir">
					<h2>Aurelia Custom Element</h2>
					<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
import {inject, bindable} from 'aurelia-framework';
import 'bootstrap-datepicker/js/bootstrap-datepicker';

@inject(Element)
export class MyDatepickerCustomElement {
  @bindable data;

  constructor(element) { this.element = element; }

	bind() { // DOM manipulation... }

	unbind() { // Cleanup... }
}
					</code></pre>
					<div class="hack-col-right">
						<p class="fragment">External libraries are imported.</p>
						<p class="fragment">Naming convention marks this as custom element.</p>
						<p class="fragment">Bindable decorator for data binding.</p>
						<p class="fragment">View template loaded by convention</p>
						<p class="fragment"><code>bind</code> and <code>unbind</code> are <a href="http://aurelia.io/docs.html#/aurelia/framework/1.0.0-beta.1.1.1/doc/article/creating-components/3">Component Lifecycle</a> methods.</p>
					</div>
				</section>

				<section data-state="ang-dir">
					<h2>Custom Element: Datepicker</h2>
					<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
bind() {
	// Find input element
	this.selector = $(this.element).find('.date');

	// Initialize datepicker
	this.selector.datepicker();

	// Update when user picks a date
	this.selector.datepicker().on('changeDate', (e) => {
		this.data = e.date;
	});

}
					</code></pre>
					<div class="hack-col-right">
						<p class="fragment">Changing data in datepicker event just works.</p>
						<p class="fragment">No internal framework knowledge required.</p>
					</div>
				</section>

				<section data-state="ang-dir">
					<h2>Custom Element: Update</h2>
					<pre class="presentation-code hack-col-left"><code class="hljs" data-trim>
export class DatePicker {
	@bindable data;
	...

	dataChanged(newVal, oldVal) {
		this.selector.datepicker('setDate', this.data);
	}

}
					</code></pre>
					<div class="hack-col-right">
						<p class="fragment">xxxChanged method called for changes to bindable properties.</p>
						<p class="fragment">
							<code>this.data</code> automatically populated with <code>newVal</code>. <a href="https://github.com/danielabar/aurelia-pluralsight/blob/master/movies-client/public/components/datepicker.js">Full example</a>
						</p>
					</div>
				</section>

				<section data-state="scope-parent">
				 	<h2>Angular Inheritance</h2>
					<p>Components can access their parent via <code>$scope</code>.</p>
					<p class="fragment">Prevents re-use and leads to hard to track down bugs due to <span class="emphasis">prototypal inheritance.</span></p>
					<div class="fragment pen-wrapper">
						<p data-height="350" data-theme-id="0" data-slug-hash="pgxYVL" data-default-tab="html" data-user="danielabar" class='codepen'>See the Pen <a href='http://codepen.io/danielabar/pen/pgxYVL/'>Angular Demo Parent Child Madness</a> by Daniela Baron (<a href='http://codepen.io/danielabar'>@danielabar</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
						<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
					</div>
				</section>

				<section data-state="scope-parent">
					<h3>Aurelia Inheritance</h3>
					<p>By default, components can not access their parent.</p>
					<p class="fragment">Can be configured if needed:</p>
					<pre class="fragment presentation-code"><code class="hljs" data-trim>
export class ChildViewModel {
  bind(bindingContext) {
    this.$parent = bindingContext;
  }
}
					</code></pre>
					<p class="fragment">Even better, use <code>EventAggregator</code> or <code>PropertyObserver</code> for component communication.</p>
				</section>

				<section data-state="angular-compare-summary">
					<h2>Summary</h2>
					<table>
						<tr>
							<th><img src="images/aurelia-logo.png" alt="Aurelia logo"></th>
							<th><img src="images/angular-logo-light.png" alt="Angular logo"></th>
						</tr>
						<tr class="fragment">
							<td>Conventions</td>
							<td>Configuration</td>
						</tr>
						<tr class="fragment">
							<td>Web standards</td>
							<td>&ldquo;The Angular Way&rdquo;</td>
						</tr>
						<tr class="fragment">
							<td>Simple DOM manipulation</td>
							<td>Directives are difficult</td>
						</tr>
						<tr class="fragment">
							<td>Data binding just works</td>
							<td>Leaky abstractions</td>
						</tr>
						<tr class="fragment">
							<td>View and Component lifecycle</td>
							<td>Kind of, but unclear</td>
						</tr>
					</table>
				</section>
			</section>

				<!-- END Daniela: Aurelia vs Angular -->

				<!-- BEGIN Kent: Aurelia vs React -->
				<section>
					<section>
						<h2>Aurelia vs React</h2>
                    </section>
                    <section>
                        <div class="react-showdown">
                            <div class="sean">It's not JavaScript!</div>
                            <div class="mike">It's just JavaScript!</div>
                        </div>
					</section>
					<section>
						<h2>JSX</h2>
                        <pre class="fragment presentation-code"><code class="jsx" data-trim>
var WelcomeBox = React.createClass({
  render: function() {
    return (
      <div className="well">
        Hello, {this.props.username}!
      </div>
    );
  }
});
ReactDOM.render(
  <WelcomeBox username="Hodor" />,
  document.getElementById('welcome')
);
                        </code></pre>
					</section>
                    <section>
                        <h2>Flux: Unidirectional Data Flow</h2>
                        <img src="images/flux.png" alt="Flux">
                    </section>
                    <section>
                        <h2>Redux: Three Principles</h2>
                        <ul>
                            <li>Single source of truth</li>
                            <li>State is read-only</li>
                            <li>Changes are made with pure functions</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Data Flow in Aurelia: Some Thoughts</h2>
                        <ul>
                            <li>One-way binding apart from input elements</li>
                            <li>State is updated by calling methods on services</li>
                            <li>Changes flow down via observers</li>
                        </ul>
                    </section>
				</section>
				<!-- END Kent: Aurelia vs React -->

				<!-- BEGIN Mike: Aurelia vs Ember -->
				<section>
					<section>
						<h2>Aurelia vs Ember</h2>
						<p>
							The Ember Way
						</p>
					</section>
					<section>
						<h2>Router</h2>
						<p>
							different...
						</p>
					</section>
				</section>
				<!-- END Mike: Aurelia vs Ember -->

				<!-- BEGIN Daniela: Gotchas -->
				<section data-transition="convex">
					<section data-transition="fade" data-state="subsection-start" data-background="images/gotchas.gif" data-background-size="80%">
						<h2 class="extra-large">Gotchas</h2>
					</section>
					<section>
						<h2>It's new...</h2>
						<ul>
							<li class="fragment">Still in beta &rarr; moving target</li>
							<li class="fragment">Documentation is a work in progress</li>
							<li class="fragment">Not a lot of Q &amp; A on Stack Overflow</li>
							<li class="fragment">JSPM is new and quirky (recommended package manager and module loader)</li>
							<li class="fragment">Bundling and optimization still needs work</li>
						</ul>
					</section>
				</section>
				<!-- END Daniela: Aurelia Overview -->

				<section data-transition="convex">
					<h2>Q &amp; A</h2>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
